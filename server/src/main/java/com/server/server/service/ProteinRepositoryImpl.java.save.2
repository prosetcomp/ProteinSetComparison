package com.server.server.service;



import java.sql.CallableStatement;
import java.sql.Connection;
import java.sql.PreparedStatement;
import javax.sql.DataSource;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import org.springframework.beans.factory.annotation.Autowired;
import java.io.*;

import java.util.*;
import org.springframework.web.context.request.RequestContextHolder;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;
import javax.persistence.criteria.Predicate;
import javax.persistence.criteria.Root;
import org.springframework.stereotype.Service;
import java.util.regex.*;

import com.fasterxml.jackson.databind.JsonNode;
import com.server.server.model.PROTEIN;
import com.server.server.repository.ProteinRepositoryCustom;
import org.json.JSONArray;
import org.json.JSONObject;
import java.util.HashMap;


@Service
public class ProteinRepositoryImpl implements ProteinRepositoryCustom {

        @PersistenceContext
        private EntityManager em;
        String sessionID;
	public Connection conn;
        
       int map_size;
       int temp_map_size=0;
     
/*        public void iterateJsonObject(List<List<String>> key_value_list, String id_json, Connection connection) throws SQLException{
        		List<List<CriteriaQuery>> criteriaList = new ArrayList<>();
           sessionID=id_json;
           conn=connection;
           map_size= key_value_list.size();
          System.out.println("key_value_list_size"+key_value_list.size());
           //Set Up Criteria For Each Query
            for(int a = 0 ;a< key_value_list.size();a++) {
				int variable=1;
				  List<String> list_element= key_value_list.get(a);
				  List<CriteriaQuery> temp_criteria = new ArrayList<>();
				  for (int b=0;b<list_element.size();b++){
					  String[] parts =list_element.get(b).split("=");
					  String key=parts[0];
					  String value =parts[1];
					
						Pattern pattern = Pattern.compile("(?i)(GO:[0]+|GO:)");
						Pattern pattern2 = Pattern.compile("(?i)(pf[0]+|pf)");
						Pattern pattern3 = Pattern.compile("(?i)(ipr[0]+|ipr)");
						Pattern pattern4 = Pattern.compile("(?i)(R-[A-Z]{3}-[0]+|R-[A-Z]{3}-)");
						Matcher matcher = pattern.matcher(value);
						Matcher matcher2 = pattern2.matcher(value);
						Matcher matcher3 = pattern3.matcher(value);
						Matcher matcher4 = pattern4.matcher(value);
						String regex_part = null;
						if (matcher.find())
						{
							regex_part=matcher.group();
							value=value.replace(regex_part, "");
						   
						}
						else if (matcher2.find())
						{
							regex_part=matcher2.group();
							value=value.replace(regex_part, "");
						   
						}
						
						else if (matcher3.find())
						{
							regex_part=matcher3.group();
							value=value.replace(regex_part, "");
						   
						}
						else if (matcher4.find())
						{
							regex_part=matcher4.group();
							value=value.replace(regex_part, "");
						   
						} 



						  String regex = "[0-9]+";
						  if(value.matches(regex)) {
							  int foo = Integer.parseInt(value);
							  
							  if(key.equals("disease_accession")) {
					            	CriteriaQuery cq =searchProteinbyDiseaseAcc (foo);
					            	temp_criteria.add(cq);
					           }
							  else if (key.equals("disease_mim")) {
					            	CriteriaQuery cq =searchProteinbyDiseaseMim (foo);
					            	temp_criteria.add(cq);
					           }
							  else if (key.equals("domain_iprid")) {
					            	CriteriaQuery cq =searchProteinbyDomainIpr_id(foo);
					            	temp_criteria.add(cq);
					           }
							  else if (key.equals("disease_mim")) {
					            	CriteriaQuery cq =searchProteinbyDiseaseMim(foo);
					            	temp_criteria.add(cq);
					           }
							  else if (key.equals("domain_pfam")) {
					            	CriteriaQuery cq =searchProteinbyDomainPfam(foo);
					            	temp_criteria.add(cq);
					           }
							  else if (key.equals("publication_pmid")) {
					            	CriteriaQuery cq =searchProteinbyPublicationPmid(foo);
					            	temp_criteria.add(cq);
					           }
							  else if (key.equals("pathway_id")) {
					            	System.out.println("PATHWAY_ID");
							CriteriaQuery cq =searchProteinbyPathwayId(foo);
					            	temp_criteria.add(cq);
					           }
							  else if (key.equals("protein_isreviewed")) {
					            	CriteriaQuery cq =searchProteinbyProteinIs_reviewed(foo);
					            	temp_criteria.add(cq);
					           }
							  else if (key.equals("protein_taxonid")) {
					            	CriteriaQuery cq =searchProteinbyProteinTaxon_id(foo);
					            	temp_criteria.add(cq);
					           }
							else if (key.equals("go_id")) {
					            	CriteriaQuery cq =searchProteinbyGo_termsTerm_id(foo);
					            	temp_criteria.add(cq);
					           }  
								criteriaList.add(variable-1, temp_criteria);;
								
						  }
						  else {
						
						      if(key.equals("disease_acronym")) {
								   CriteriaQuery cq =searchProteinbyDiseaseAcronym (value);
			        	            	   temp_criteria.add(cq);
		        	               } 
							  else if (key.equals("disease_identifier")) {
						            	CriteriaQuery cq =searchProteinbyDiseaseIdentifier(value);
						            	temp_criteria.add(cq);
					           }
							  else if (key.equals("goterms_name")) {
						            	CriteriaQuery cq =searchProteinbyGo_termsName(value);
						            	temp_criteria.add(cq);
					           }
							  else if (key.equals("domain_name")) {
						            	CriteriaQuery cq =searchProteinbyDomainName(value);
						            	temp_criteria.add(cq);
					           }
							  else if (key.equals("taxon_name")) {
						            	CriteriaQuery cq = searchProteinbyTaxonName(value);
						            	temp_criteria.add(cq);
					           }
							  else if (key.equals("pdb_pdb")) {
						            	CriteriaQuery cq = searchProteinbyProtein_pdbPdb(value);
						            	temp_criteria.add(cq);
					           }
							  else if (key.equals("pdb_chain")) {
						            	CriteriaQuery cq = searchProteinbyProtein_pdbChain(value);
						            	temp_criteria.add(cq);
					           }
							  else if (key.equals("protein_name")) {
						            	CriteriaQuery cq = searchProteinbyProteinName(value);
						            	temp_criteria.add(cq);
					           }
							  else if (key.equals("secondary_accession")) {
						            	CriteriaQuery cq = searchProteinbyPrimary_SecondarySecondaryAccession(value);
						            	temp_criteria.add(cq);
						      }
							  else if (key.equals("publication_title")) {
						            	CriteriaQuery cq = searchProteinbyPublicationTitle(value);
						            	temp_criteria.add(cq);
					           }
							  else if (key.equals("pathway_name")) {
						            	CriteriaQuery cq = searchProteinbyPathwayName(value);
						            	temp_criteria.add(cq);
					           }
							  else if (key.equals("protein_accession")) {
						            	CriteriaQuery cq = searchProteinbyProteinAccession(value);
						            	temp_criteria.add(cq);
					           }
							  else if (key.equals("protein_id")) {
						            	CriteriaQuery cq = searchProteinbyProteinId(value);
						            	temp_criteria.add(cq);
					           }
							  else if (key.equals("allergome")||key.equals("biocyc") || key.equals("biogrid") || 
									  key.equals("biomuta") || key.equals("chembl") || key.equals("dictybase")
									  || key.equals("drugbank") || key.equals("echobase") || key.equals("embl")
									  || key.equals("embl-cds") || key.equals("ensembl") || key.equals("ensemblgenome")
									  || key.equals("ensemblgenome_pro") || key.equals("ensemblgenome_trs") || key.equals("ensembl_pro")
									  || key.equals("ensembl_trs") || key.equals("flybase") || key.equals("genecards")
									  || key.equals("genedb") || key.equals("geneid") || key.equals("gene_name")
									  || key.equals("gene_orderedlocusname") || key.equals("gene_orfname") || key.equals("genereviews") 
									  || key.equals("gene_synonym") || key.equals("gi") || key.equals("hgnc")
									  || key.equals("kegg") || key.equals("orthodb") || key.equals("peroxibase")
									  || key.equals("pombase") || key.equals("rebase") || key.equals("refseq")
									  || key.equals("refseq_nt") || key.equals("rgd") || key.equals("sgd") 
									  || key.equals("string") || key.equals("unigene") || key.equals("uniparc")
									  || key.equals("unipathway") || key.equals("uniprotkb-id") || key.equals("uniref100") 
									  || key.equals("uniref50") || key.equals("uniref90") || key.equals("vectorbase")
									  || key.equals("wormbase") || key.equals("xenbase")
									  ) {
					            	CriteriaQuery cq = searchProteinbyProtein_crossrefTypeCrossref(key,value);
					            	temp_criteria.add(cq);
					            	
					           }
							else if(key.equals("uniprot_accession")) {
						             Set<String> all_uniprot_accession=new HashSet<>();
							     String[] words = value.split(",");
							     for(int index=0;index<words.length;index++) {
			                    	  		 all_uniprot_accession.add(words[index]);
			                    	 
			                    		     }
			                     		    System.out.println("all_uniprot_accession");
			               			   variable=variable-1;
							    temp_map_size=temp_map_size-1; 
					     		    collect_lastset.add(all_uniprot_accession);
								  
							}
							  criteriaList.add(variable-1, temp_criteria);
						  }
				  }
				System.out.println("CriteriaList"+criteriaList);
				System.out.println("Variable="+variable);	  
				variable++;
				  
			 }
            		
            		parseListOfList(criteriaList,conn);
            
              
        	 }
  */
public void iterateJsonObject(List<List<String>> key_value_list, String id_json, Connection connection) throws SQLException{
        		List<List<CriteriaQuery>> criteriaList = new ArrayList<>();
           sessionID=id_json;
           conn=connection;
           map_size= key_value_list.size();
          System.out.println("key_value_list_size"+key_value_list.size());
	
           //Set Up Criteria For Each Query
		 int variable=0;
            for(int a = 0 ;a< key_value_list.size();a++) {
            		//variable=0;
            		temp_map_size++;
            		System.out.println("First For LOOP temp_map_size = " + temp_map_size);
				  List<String> list_element= key_value_list.get(a);
				  List<CriteriaQuery> temp_criteria = new ArrayList<>();
				  for (int b=0;b<list_element.size();b++){
					  String[] parts =list_element.get(b).split("=");
					  String key=parts[0];
					  String value =parts[1];
					
						Pattern pattern = Pattern.compile("(?i)(GO:[0]+|GO:)");
						Pattern pattern2 = Pattern.compile("(?i)(pf[0]+|pf)");
						Pattern pattern3 = Pattern.compile("(?i)(ipr[0]+|ipr)");
						Pattern pattern4 = Pattern.compile("(?i)(R-[A-Z]{3}-[0]+|R-[A-Z]{3}-)");
						Matcher matcher = pattern.matcher(value);
						Matcher matcher2 = pattern2.matcher(value);
						Matcher matcher3 = pattern3.matcher(value);
						Matcher matcher4 = pattern4.matcher(value);
						String regex_part = null;
						if (matcher.find())
						{
							regex_part=matcher.group();
							value=value.replace(regex_part, "");
						   
						}
						else if (matcher2.find())
						{
							regex_part=matcher2.group();
							value=value.replace(regex_part, "");
						   
						}
						
						else if (matcher3.find())
						{
							regex_part=matcher3.group();
							value=value.replace(regex_part, "");
						   
						}
						else if (matcher4.find())
						{
							regex_part=matcher4.group();
							value=value.replace(regex_part, "");
						   
						} 
						
/*						if(key.equals("uniprot_accession")) {
							   Set<String> all_uniprot_accession=new HashSet<>();
							     String[] words = value.split(",");
							     for(int index=0;index<words.length;index++) {
			                    	  		 all_uniprot_accession.add(words[index]);
			                    	 
			                    		     }
			                     		    System.out.println(all_uniprot_accession);
			               			    temp_map_size--; 
					     		    collect_lastset.add(all_uniprot_accession);
							   createTempTable(sessionID,collect_lastset);
							   System.out.println(collect_lastset); 
						  }
*/

						  String regex = "[0-9]+";
						  if(value.matches(regex)) {
							  int foo = Integer.parseInt(value);
							  
							  if(key.equals("disease_accession")) {
					            	CriteriaQuery cq =searchProteinbyDiseaseAcc (foo);
					            	temp_criteria.add(cq);
					           }
							  else if (key.equals("disease_mim")) {
					            	CriteriaQuery cq =searchProteinbyDiseaseMim (foo);
					            	temp_criteria.add(cq);
					           }
							  else if (key.equals("domain_iprid")) {
					            	CriteriaQuery cq =searchProteinbyDomainIpr_id(foo);
					            	temp_criteria.add(cq);
					           }
							  else if (key.equals("disease_mim")) {
					            	CriteriaQuery cq =searchProteinbyDiseaseMim(foo);
					            	temp_criteria.add(cq);
					           }
							  else if (key.equals("domain_pfam")) {
					            	CriteriaQuery cq =searchProteinbyDomainPfam(foo);
					            	temp_criteria.add(cq);
					           }
							  else if (key.equals("publication_pmid")) {
					            	CriteriaQuery cq =searchProteinbyPublicationPmid(foo);
					            	temp_criteria.add(cq);
					           }
							  else if (key.equals("pathway_id")) {
					            	System.out.println("PATHWAY_ID");
							CriteriaQuery cq =searchProteinbyPathwayId(foo);
					            	temp_criteria.add(cq);
					           }
							  else if (key.equals("protein_isreviewed")) {
					            	CriteriaQuery cq =searchProteinbyProteinIs_reviewed(foo);
					            	temp_criteria.add(cq);
					           }
							  else if (key.equals("protein_taxonid")) {
					            	CriteriaQuery cq =searchProteinbyProteinTaxon_id(foo);
					            	temp_criteria.add(cq);
					           }
							else if (key.equals("go_id")) {
					            	CriteriaQuery cq =searchProteinbyGo_termsTerm_id(foo);
					            	temp_criteria.add(cq);
					           }  
								criteriaList.add(variable, temp_criteria);
								// variable++;
													
						  }
						   
						  else {
						
						      if(key.equals("disease_acronym")) {
								   CriteriaQuery cq =searchProteinbyDiseaseAcronym (value);
			        	            	   temp_criteria.add(cq);
		        	               } 
							  else if (key.equals("disease_identifier")) {
						            	CriteriaQuery cq =searchProteinbyDiseaseIdentifier(value);
						            	temp_criteria.add(cq);
					           }
							  else if (key.equals("goterms_name")) {
						            	CriteriaQuery cq =searchProteinbyGo_termsName(value);
						            	temp_criteria.add(cq);
					           }
							  else if (key.equals("domain_name")) {
						            	CriteriaQuery cq =searchProteinbyDomainName(value);
						            	temp_criteria.add(cq);
					           }
							  else if (key.equals("taxon_name")) {
						            	CriteriaQuery cq = searchProteinbyTaxonName(value);
						            	temp_criteria.add(cq);
					           }
							  else if (key.equals("pdb_pdb")) {
						            	CriteriaQuery cq = searchProteinbyProtein_pdbPdb(value);
						            	temp_criteria.add(cq);
					           }
							  else if (key.equals("pdb_chain")) {
						            	CriteriaQuery cq = searchProteinbyProtein_pdbChain(value);
						            	temp_criteria.add(cq);
					           }
							  else if (key.equals("protein_name")) {
						            	CriteriaQuery cq = searchProteinbyProteinName(value);
						            	temp_criteria.add(cq);
					           }
							  else if (key.equals("secondary_accession")) {
						            	CriteriaQuery cq = searchProteinbyPrimary_SecondarySecondaryAccession(value);
						            	temp_criteria.add(cq);
						      }
							  else if (key.equals("publication_title")) {
						            	CriteriaQuery cq = searchProteinbyPublicationTitle(value);
						            	temp_criteria.add(cq);
					           }
							  else if (key.equals("pathway_name")) {
						            	CriteriaQuery cq = searchProteinbyPathwayName(value);
						            	temp_criteria.add(cq);
					           }
							  else if (key.equals("protein_accession")) {
						            	CriteriaQuery cq = searchProteinbyProteinAccession(value);
						            	temp_criteria.add(cq);
					           }
							  else if (key.equals("protein_id")) {
						            	CriteriaQuery cq = searchProteinbyProteinId(value);
						            	temp_criteria.add(cq);
					           }
							  else if (key.equals("allergome")||key.equals("biocyc") || key.equals("biogrid") || 
									  key.equals("biomuta") || key.equals("chembl") || key.equals("dictybase")
									  || key.equals("drugbank") || key.equals("echobase") || key.equals("embl")
									  || key.equals("embl-cds") || key.equals("ensembl") || key.equals("ensemblgenome")
									  || key.equals("ensemblgenome_pro") || key.equals("ensemblgenome_trs") || key.equals("ensembl_pro")
									  || key.equals("ensembl_trs") || key.equals("flybase") || key.equals("genecards")
									  || key.equals("genedb") || key.equals("geneid") || key.equals("gene_name")
									  || key.equals("gene_orderedlocusname") || key.equals("gene_orfname") || key.equals("genereviews") 
									  || key.equals("gene_synonym") || key.equals("gi") || key.equals("hgnc")
									  || key.equals("kegg") || key.equals("orthodb") || key.equals("peroxibase")
									  || key.equals("pombase") || key.equals("rebase") || key.equals("refseq")
									  || key.equals("refseq_nt") || key.equals("rgd") || key.equals("sgd") 
									  || key.equals("string") || key.equals("unigene") || key.equals("uniparc")
									  || key.equals("unipathway") || key.equals("uniprotkb-id") || key.equals("uniref100") 
									  || key.equals("uniref50") || key.equals("uniref90") || key.equals("vectorbase")
									  || key.equals("wormbase") || key.equals("xenbase")
									  ) {
					            	CriteriaQuery cq = searchProteinbyProtein_crossrefTypeCrossref(key,value);
					            	temp_criteria.add(cq);
					            	
					           }
						    else if(key.equals("uniprot_accession")) {
                                                        String[] words = value.split(",");
                                                         for(int index=0;index<words.length;index++) {
                                                                 all_uniprot_accession.add(words[index]);
                     
                                                        }
                                                        System.out.println("All Uniprot Accession "+all_uniprot_accession);
                                                        temp_map_size--; 
                //                                        variable--;                                
                                                        collect_lastset.add(all_uniprot_accession);
        
                                                         //createTempTable(sessionID,collect_lastset);
                               
                                                }

/*						   else if(key.equals("uniprot_id")) {
			                                String[] words = value.split(",");
        		                                for(int index=0;index<words.length;index++) {
                            	                        all_uniprot_accession.add(words[index]);
 
                                                   }
                                                  System.out.println("All Uniprot Accession "+all_uniprot_accession);
                                                 temp_map_size--; 
//                                        variable--;                                
                              //  collect_lastset.add(all_uniprot_accession);

                                 //createTempTable(sessionID,collect_lastset);
       
						    }
						     
*/

 else if(key.equals("uniprot_id")) {
                             String[] words = value.split(",");
                             String table_name_uniprotid="UniprotID_" +sessionID;
                             List<String> uniprot_id = new ArrayList<>();

                             for(int index=0;index<words.length;index++) {
                            	      uniprot_id.add(words[index]);
                            }
                        	 Statement stmt = conn.createStatement();	
                        	 String sql = "CREATE TEMPORARY TABLE " +table_name_uniprotid +
     	                            "(UNIPROT_ID VARCHAR(40) not NULL ," +
     	                            "PRIMARY KEY my_pkey (UNIPROT_ID))";
                        	 stmt.executeUpdate(sql);
                        	  String insert_sql="INSERT INTO " +table_name_uniprotid +"(UNIPROT_ID) VALUES(?)";
              		      PreparedStatement ps = conn.prepareStatement(insert_sql);
              			
              			final int batchSize = 10000;
            			   int count = 0;
            				for(String protein:uniprot_id){
            				       ps.setString(1, protein);
            				       ps.addBatch();
            				    if(++count % batchSize == 0) {
            	    				System.out.println(count);
            					ps.executeBatch();
            				 		
            				     }           
            				}
            				ps.executeBatch();
            				
            				//CHECK TABLE AND ELEMENTS
            				ResultSet rs = stmt.executeQuery("select * from " + table_name_uniprotid);
            				 System.out.println("Table name:" + table_name_uniprotid);
	            				while(rs.next()) {
	            			          System.out.println(rs.getString("UNIPROT_ID"));
	            				}
						CriteriaBuilder builder = em.getCriteriaBuilder();
	            				CriteriaQuery<PROTEIN> crit = builder.createQuery(PROTEIN.class);
	            				Root<PROTEIN> protein = crit.from(PROTEIN.class);
	            				List<Predicate> restrictions = new ArrayList<>();
						System.out.println("Before join operation");       
	     				protein.join(table_name_uniprotid);
	            				crit.select(protein.get("ACCESSION")).where(restrictions.toArray(new Predicate[]{}));	          
	            				List<PROTEIN> result = em.createQuery(crit).getResultList();
	            				System.out.println("Result of this table join is : " + result);     						  
                       
                             temp_map_size--; 
                           
                         }

							
							  criteriaList.add(variable, temp_criteria);
						//	  variable++;
							
						  }

					/*	if(key.equals("uniprot_accession")) {
			                                String[] words = value.split(",");
                        			         for(int index=0;index<words.length;index++) {
                                    				 all_uniprot_accession.add(words[index]);
                     
                                 			}
                                			System.out.println("All Uniprot Accession "+all_uniprot_accession);
                                			temp_map_size--; 
							variable--;                                
                                			//collect_lastset.add(all_uniprot_accession);
	
                              				 //createTempTable(sessionID,collect_lastset);
                               
                       				}*/

						
				  }

				
 
					  
				  System.out.println("Variable "+variable);    
				variable++;
				 //System.out.println("Variable "+variable);  
			 }
            			
				System.out.println("CriteriaList"+criteriaList);
				System.out.println("CriteriaList"+criteriaList.size());				
            			parseListOfList(criteriaList,conn);
  
            
              
        	 }
    
        int current_position=1;        
	
        public void parseListOfList(List<List<CriteriaQuery>> criteriaList, Connection conn) throws SQLException{
        		if(temp_map_size==0){
				System.out.println("Temp_Map_Size=0");
			//	collect_lastset.add(all_uniprot_accession);
				createTempTable(sessionID,collect_lastset);
				//processSetList("AND" , List<Set<String>> collect_lastset,map_size);
}
			System.out.println("ParseListOfList= " + temp_map_size);        		
        		 for(int a = 0 ;a<temp_map_size;a++) {
				  List<CriteriaQuery> cl =criteriaList.get(a);
        			System.out.println("cl is " + cl);
				  runCriteriaList(cl,a+1);
			 	  current_position++; 
				System.out.println("PArse list of list for loop is working");
			 }
		 current_position=1;
		 temp_map_size=0;   			    		 
        	}

        public void runCriteriaList(List<CriteriaQuery> cl,int query_number){
	        	int i = cl.size()-1;
	        List<Set<String>> returnList= new ArrayList<Set<String>>();    
	        while(i>-1) {
	         	CriteriaQuery cquery=cl.get(i);
		        List<String> result = em.createQuery(cquery).getResultList();
		  		Set<String> resultSet = new HashSet<>(result);
				returnList.add(resultSet);
		                i--;
	         }
	        processSetList("AND",returnList,query_number);  
             
        }
        
  

	 List<Set<String>> collect_lastset =new ArrayList<Set<String>>();
	 Set<String> all_uniprot_accession=new HashSet<>();
     public void processSetList(String OperationList , List<Set<String>> returnList,int query_number) {	   
		System.out.println("ReturlnList is: " + returnList);
	        Set<String> finalIntersectionSet = returnList.get(0);
	        Set<String> lastset = new HashSet<>();
  	        OperationList="AND";
  	        if(returnList.size()==1) {
                  lastset.addAll(finalIntersectionSet);
                         }
       		 for(int i=1;i<returnList.size();i++) {
       			 finalIntersectionSet.retainAll(returnList.get(i));
       			 lastset.addAll(finalIntersectionSet);
       		 }
       		 collect_lastset.add(lastset);                         
			 System.out.println("Collect_lastset process function: " + collect_lastset);
/*			 if(all_uniprot_accession.size()>0) {
                                         collect_lastset.add(all_uniprot_accession);
                            }
*/			 if(current_position==temp_map_size) {
				System.out.println("In create temp table!!");
				/* if(all_uniprot_accession.size()>0) {
                                         collect_lastset.add(all_uniprot_accession);
                            }*/
				System.out.println("Collect_lastset process function: " + collect_lastset);				
				 createTempTable(sessionID,collect_lastset);
	       	 	  }
//    			writeFile(lastset);
//			System.out.println("LastSet" + " " + lastset);	
			 			     		
       	 }
        
        public void writeFile(Set<String> lastset) {
        		String fileName= "/home/ilayda/result.txt";
            try{  
                   PrintWriter outputStream = new PrintWriter(fileName);
                   outputStream.println("Result is :" + " " +lastset);
                   outputStream.close();     
            }
            catch(FileNotFoundException fnfe){
            	System.out.println(fnfe.getMessage());
            }
            // outputStream.close();
        }   


		public void createTempTable(String session_ID, List<Set<String>> collect_lastset)  {
			System.out.println("Inside Test Method" + collect_lastset);
		
		    try {
		
//		    System.out.println("In the method connection:" + conn);    
		    for(int group=1;group<=collect_lastset.size();group++) {
		        	 Statement stmt = conn.createStatement();	
			     String table_name = "protlist"+group+"_"+session_ID;
		        	 System.out.println(table_name);
		        	 String sql = "CREATE TEMPORARY TABLE " + table_name +
	                            "(ACCESSION VARCHAR(40) not NULL ," +
	                            "PRIMARY KEY my_pkey (ACCESSION))";
						  
//		        System.out.println(sql);
		        stmt.executeUpdate(sql);
		        String insert_sql="INSERT INTO " +table_name +"(ACCESSION) VALUES(?)";
		        PreparedStatement ps = conn.prepareStatement(insert_sql);
//				System.out.println(insert_sql);
				List<String> accession = new ArrayList<>();
				accession.addAll(collect_lastset.get(group-1));
//			    System.out.println("Accession" + accession);
			    //BATCH
			   final int batchSize = 10000;
			   int count = 0;
				for(String protein:accession){
				       ps.setString(1, protein);
				       ps.addBatch();
				    if(++count % batchSize == 0) {
	    				System.out.println(count);
					ps.executeBatch();
				//	callStoredProcedure(conn,map_size,sessionID);
			     		
				     }	
		               }
				ps.executeBatch();
				
				//CHECK TABLE AND ELEMENTS
				ResultSet rs = stmt.executeQuery("select * from " + table_name);
				 System.out.println("Table name:" + table_name);
				while(rs.next()) {
			          System.out.println(rs.getString("ACCESSION"));
				}
				        
					        	 
		     }
		   for(int table_index=0;table_index<map_size;table_index++){ 
		    if(collect_lastset.size()==map_size){
			System.out.println("Collect_lastset is equal to map size");
		     //Call Stored Procedure
		     	callStoredProcedure(conn,map_size,sessionID);
			break;
		     }
		System.out.println("For loop" + collect_lastset); 
		}         
		    } catch (SQLException e) {
		        // TODO Auto-generated catch block
		        e.printStackTrace();
		    } catch(NullPointerException e){
		        System.out.println("Null Pointer exception");
		    }
		}
	

		public void callStoredProcedure(Connection connection , int querynumber ,String session_id) throws SQLException {

			if(map_size==1) {
							//SET
					      CallableStatement gm_1set =connection.prepareCall("{ call GM_1SET(?) }");
					      gm_1set.setString(1, sessionID);
					      gm_1set.execute();  
			               ResultSet rs_gm_a = gm_1set.executeQuery("select * from GM_a_"+sessionID);
					      System.out.println("GM_1SET && GM_a_"+sessionID); 
			              while(rs_gm_a.next()) {
			                       System.out.println(rs_gm_a.getString("ONTOLOGY"));
			              }  
			              //SET
			              CallableStatement gb_1set =connection.prepareCall("{ call GB_1SET(?) }");
			              gb_1set.setString(1, sessionID);
			              gb_1set.execute();  
			              ResultSet rs_gb_a = gb_1set.executeQuery("select * from GB_a_"+sessionID);
/*					      System.out.println("GB_1SET && GB_a_sessionID"); 
			              while(rs_gb_a.next()) {
			                        System.out.println(rs_gb_a.getString("ONTOLOGY"));
			              }   
*/		 
			              //SET
			              CallableStatement pw_1set =connection.prepareCall("{ call PW_1SET(?) }");
			              pw_1set.setString(1, sessionID);
			              pw_1set.execute();  
			              System.out.println("Callable 1");  
					      ResultSet rs_pw_a = pw_1set.executeQuery("select * from PW_a_"+sessionID);
/*					      System.out.println("PW_1SET && PW_a_sessionID"); 
			              while(rs_pw_a.next()) {
			                        System.out.println(rs_pw_a.getString("PATHWAY"));
			              }  
*/			 
			              //SET
			              CallableStatement dm_1set =connection.prepareCall("{ call DM_1SET(?) }");
			              dm_1set.setString(1, sessionID);
			              dm_1set.execute();  
			              System.out.println("Callable 1");  
					      ResultSet rs_dm_a = dm_1set.executeQuery("select * from DM_a_"+sessionID);
/*					      System.out.println("DM_1SET && DM_a_sessionID"); 
			              while(rs_dm_a.next()) {
			                        System.out.println(rs_dm_a.getString("DOMAIN"));
			              }
*/			              
			              //SET
			              CallableStatement pr_1set =connection.prepareCall("{ call PROT_1SET(?) }");
			              pr_1set.setString(1, sessionID);
			              pr_1set.execute();  

		
			              callJoinFunction(conn);
		
				}
			else if(map_size==2) {
				  	System.out.println("Store procedure for 2 set");
				    
				  	//GM2SET
				  	//SET
				    CallableStatement gm_2set=connection.prepareCall("{ call GM_2SET(?) }");
				    gm_2set.setString(1, sessionID);
				    gm_2set.execute();  
                		ResultSet rs_gm_a = gm_2set.executeQuery("select * from GM_a_"+sessionID);
/*                		System.out.println("GM_2SET && GM_a_sessionID "); 
                		while(rs_gm_a.next()) {              
                       		        System.out.println(rs_gm_a.getString("ONTOLOGY"));
                		} 
                		
                		//SET
       	             ResultSet rs_gm_b = gm_2set.executeQuery("select * from GM_b_"+sessionID);
                		System.out.println("GM_2SET && GM_b_sessionID ");  
                		while(rs_gm_b.next()) {
                        	 System.out.println(rs_gm_b.getString("ONTOLOGY"));
                		} 
      		
                		//SET
              		ResultSet rs_gm_c = gm_2set.executeQuery("select * from GM_c_"+sessionID);
                		System.out.println("GM_2SET && GM_c_sessionID "); 
                		while(rs_gm_c.next()) {                          
                       		        System.out.println(rs_gm_c.getString("ONTOLOGY"));
                		} 
              		//GB2SET
  */              		
         	        //SET
                		CallableStatement gb_2set =connection.prepareCall("{ call GB_2SET(?) }");
  	                gb_2set.setString(1, sessionID);
  	                gb_2set.execute();  
  	                System.out.println("Callable 2");  
  /*			        ResultSet rs_gb_a = gb_2set.executeQuery("select * from GB_a_"+sessionID);
  			        System.out.println("GB_2SET && GB_a_sessionID"); 
  	                while(rs_gb_a.next()) {
  	                        System.out.println(rs_gb_a.getString("ONTOLOGY"));
  	                }  
  	                //SET
  	                ResultSet rs_gb_b = gb_2set.executeQuery("select * from GB_b_"+sessionID);
			        System.out.println("GB_2SET && GB_b_sessionID"); 
	                while(rs_gb_b.next()) {
	                        System.out.println(rs_gb_b.getString("ONTOLOGY"));
	                }  

	              //SET
	                ResultSet rs_gb_c = gb_2set.executeQuery("select * from GB_c_"+sessionID);
			        System.out.println("GB_2SET && GB_c_sessionID"); 
	                while(rs_gb_c.next()) {
	                        System.out.println(rs_gb_c.getString("ONTOLOGY"));
	                }  
	                
*/	                //PW2SET
		            //SET
	                CallableStatement pw_2set =connection.prepareCall("{ call PW_2SET(?) }");
	                pw_2set.setString(1, sessionID);
	                pw_2set.execute();  
  	                System.out.println("Callable 2");  
  			        ResultSet rs_pw_a = pw_2set.executeQuery("select * from PW_a_"+sessionID);
  /*			        System.out.println("PW_2SET && PW_a_sessionID"); 
  	                while(rs_pw_a.next()) {
  	                        System.out.println(rs_pw_a.getString("PATHWAY"));
  	                }  
  	              
	              //SET
  	                ResultSet rs_pw_b = pw_2set.executeQuery("select * from PW_b_"+sessionID);
			        System.out.println("PW_2SET && PW_b_sessionID"); 
	                while(rs_pw_b.next()) {
	                        System.out.println(rs_pw_b.getString("PATHWAY"));
	                } 
	                
		              //SET
	                ResultSet rs_pw_c = pw_2set.executeQuery("select * from PW_c_"+sessionID);
			        System.out.println("PW_2SET && PW_c_sessionID"); 
	                while(rs_pw_c.next()) {
	                        System.out.println(rs_pw_c.getString("PATHWAY"));
	                }  
	                
*/	                
	                //DM2SET
		            //SET
	                CallableStatement dm_2set =connection.prepareCall("{ call DM_2SET(?) }");
		            dm_2set.setString(1, sessionID);
		            dm_2set.execute();  
		            System.out.println("Callable 1");  
/*				    ResultSet rs_dm_a = dm_2set.executeQuery("select * from DM_a_"+sessionID);
				    System.out.println("DM_2SET && DM_a_sessionID"); 
		            while(rs_dm_a.next()) {
		                    System.out.println(rs_dm_a.getString("DOMAIN"));
		            }  
		             
		            //SET
				    ResultSet rs_dm_b = dm_2set.executeQuery("select * from DM_b_"+sessionID);
				    System.out.println("DM_2SET && DM_b_sessionID"); 
		            while(rs_dm_b.next()) {
		                   System.out.println(rs_dm_b.getString("DOMAIN"));
		            }
		           
		              //SET
		            ResultSet rs_dm_c = dm_2set.executeQuery("select * from DM_c_"+sessionID);
				    System.out.println("DM_2SET && DM_c_sessionID"); 
		            while(rs_dm_c.next()) {
		                   System.out.println(rs_dm_c.getString("DOMAIN"));
		            }  
		            //PROT2SET
*/		            	//SET
		            CallableStatement pr_2set =connection.prepareCall("{ call PROT_2SET(?) }");
		            pr_2set.setString(1, sessionID);
		            pr_2set.execute();  
				System.out.println("End of set");
				 callJoinFunction(conn); 				
			}
			else if(querynumber==3) {
					System.out.println("Store procedure for 3 set");
				    //GM3SET
					//SET
					CallableStatement gm_3set=connection.prepareCall("{ call GM_3SET(?) }");
					gm_3set.setString(1, sessionID);
					gm_3set.execute();  
             		ResultSet rs_gm_a = gm_3set.executeQuery("select * from GM_a_"+sessionID);
             		System.out.println("GM_3SET && GM_a_sessionID "); 
             		while(rs_gm_a.next()) {              
                    		        System.out.println(rs_gm_a.getString("ONTOLOGY"));
             		} 